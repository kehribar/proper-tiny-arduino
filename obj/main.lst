
obj/main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000fe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  000000fe  00000192  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  0080006e  0080006e  000001a0  2**0
                  ALLOC
  3 .stab         00001200  00000000  00000000  000001a0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ce9  00000000  00000000  000013a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000040  00000000  00000000  00002090  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000000d4  00000000  00000000  000020d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000028  00000000  00000000  000021a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000167  00000000  00000000  000021cc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	ldi	r24, 13		;
	rcall	1f		;
	ldi	r24, 10		;/
1:
#endif
	push	ZH
   0:	10 c0       	rjmp	.+32     	; 0x22 <__ctors_end>
	push	ZL
   2:	2a c0       	rjmp	.+84     	; 0x58 <__bad_interrupt>
	lds	ZL, xfunc_out+0	;Pointer to the registered output function.
   4:	29 c0       	rjmp	.+82     	; 0x58 <__bad_interrupt>
   6:	28 c0       	rjmp	.+80     	; 0x58 <__bad_interrupt>
	lds	ZH, xfunc_out+1	;/
   8:	27 c0       	rjmp	.+78     	; 0x58 <__bad_interrupt>
   a:	26 c0       	rjmp	.+76     	; 0x58 <__bad_interrupt>
	sbiw	ZL, 0
   c:	25 c0       	rjmp	.+74     	; 0x58 <__bad_interrupt>
	breq	2f
   e:	24 c0       	rjmp	.+72     	; 0x58 <__bad_interrupt>
	icall
  10:	23 c0       	rjmp	.+70     	; 0x58 <__bad_interrupt>
2:	pop	ZL
  12:	22 c0       	rjmp	.+68     	; 0x58 <__bad_interrupt>
	pop	ZH
  14:	21 c0       	rjmp	.+66     	; 0x58 <__bad_interrupt>
	ret
  16:	20 c0       	rjmp	.+64     	; 0x58 <__bad_interrupt>

#ifdef USE_XPUTS
.global xputs
.func xputs
xputs:
	_MOVW	ZH,ZL, r25,r24	; Z = pointer to rom string
  18:	1f c0       	rjmp	.+62     	; 0x58 <__bad_interrupt>
1:	_LPMI	r24
  1a:	1e c0       	rjmp	.+60     	; 0x58 <__bad_interrupt>
	cpi	r24, 0
  1c:	1d c0       	rjmp	.+58     	; 0x58 <__bad_interrupt>
	breq	2f
  1e:	1c c0       	rjmp	.+56     	; 0x58 <__bad_interrupt>
	rcall	xputc
  20:	1b c0       	rjmp	.+54     	; 0x58 <__bad_interrupt>

00000022 <__ctors_end>:
	rjmp	1b
  22:	11 24       	eor	r1, r1
2:	ret
  24:	1f be       	out	0x3f, r1	; 63
#ifdef USE_XITOA
.global xitoa
.func xitoa
xitoa:
				;r25:r22 = value, r20 = base, r18 = digits
	clr	r31		;r31 = stack level
  26:	cf e5       	ldi	r28, 0x5F	; 95
	ldi	r30, ' '	;r30 = sign
  28:	d2 e0       	ldi	r29, 0x02	; 2
	ldi	r19, ' '	;r19 = filler
  2a:	de bf       	out	0x3e, r29	; 62
	sbrs	r20, 7		;When base indicates signd format and the value
  2c:	cd bf       	out	0x3d, r28	; 61

0000002e <__do_copy_data>:
	rjmp	0f		;is minus, add a '-'.
  2e:	10 e0       	ldi	r17, 0x00	; 0
	neg	r20		;
  30:	a0 e6       	ldi	r26, 0x60	; 96
	sbrs	r25, 7		;
  32:	b0 e0       	ldi	r27, 0x00	; 0
	rjmp	0f		;
  34:	ee ef       	ldi	r30, 0xFE	; 254
	ldi	r30, '-'	;
  36:	f0 e0       	ldi	r31, 0x00	; 0
	com	r22		;
  38:	02 c0       	rjmp	.+4      	; 0x3e <__SP_H__>
	com	r23		;
  3a:	05 90       	lpm	r0, Z+
	com	r24		;
  3c:	0d 92       	st	X+, r0
	com	r25		;
  3e:	ae 36       	cpi	r26, 0x6E	; 110
	adc	r22, r1		;
  40:	b1 07       	cpc	r27, r17
	adc	r23, r1		;
  42:	d9 f7       	brne	.-10     	; 0x3a <__CCP__+0x6>

00000044 <__do_clear_bss>:
	adc	r24, r1		;
  44:	10 e0       	ldi	r17, 0x00	; 0
	adc	r25, r1		;/
  46:	ae e6       	ldi	r26, 0x6E	; 110
0:	sbrs	r18, 7		;When digits indicates zero filled,
  48:	b0 e0       	ldi	r27, 0x00	; 0
	rjmp	1f		;filler is '0'.
  4a:	01 c0       	rjmp	.+2      	; 0x4e <.do_clear_bss_start>

0000004c <.do_clear_bss_loop>:
	neg	r18		;
  4c:	1d 92       	st	X+, r1

0000004e <.do_clear_bss_start>:
	ldi	r19, '0'	;/
  4e:	a0 37       	cpi	r26, 0x70	; 112
				;----- string conversion loop
1:	ldi	r21, 32		;r26 = r25:r22 % r20
  50:	b1 07       	cpc	r27, r17
	clr	r26		;r25:r22 /= r20
  52:	e1 f7       	brne	.-8      	; 0x4c <.do_clear_bss_loop>
2:	lsl	r22		;
  54:	25 d0       	rcall	.+74     	; 0xa0 <main>
	rol	r23		;
  56:	51 c0       	rjmp	.+162    	; 0xfa <_exit>

00000058 <__bad_interrupt>:
	rol	r24		;
  58:	d3 cf       	rjmp	.-90     	; 0x0 <__vectors>

0000005a <xmit>:
	rol	r25		;
  5a:	0f b6       	in	r0, 0x3f	; 63
	rol	r26		;
  5c:	80 95       	com	r24
	cp	r26, r20	;
  5e:	9a e0       	ldi	r25, 0x0A	; 10
	brcs	3f		;
  60:	f8 94       	cli
	sub	r26, r20	;
  62:	70 e2       	ldi	r23, 0x20	; 32
	inc	r22		;
  64:	7a 95       	dec	r23
3:	dec	r21		;
  66:	f1 f7       	brne	.-4      	; 0x64 <xmit+0xa>
	brne	2b		;/
  68:	08 f0       	brcs	.+2      	; 0x6c <xmit+0x12>
	cpi	r26, 10		;r26 is a numeral digit '0'-'F'
  6a:	c0 9a       	sbi	0x18, 0	; 24
	brcs	4f		;
  6c:	08 f4       	brcc	.+2      	; 0x70 <xmit+0x16>
	subi	r26, -7		;
  6e:	c0 98       	cbi	0x18, 0	; 24
4:	subi	r26, -'0'	;/
  70:	86 95       	lsr	r24
	push	r26		;Stack it
  72:	9a 95       	dec	r25
	inc	r31		;/
  74:	b1 f7       	brne	.-20     	; 0x62 <xmit+0x8>
	cp	r22, r1		;Repeat until r25:r22 gets zero
  76:	0f be       	out	0x3f, r0	; 63
	cpc	r23, r1		;
  78:	08 95       	ret

0000007a <rcvr>:
	cpc	r24, r1		;
  7a:	0f b6       	in	r0, 0x3f	; 63
	cpc	r25, r1		;
  7c:	80 e8       	ldi	r24, 0x80	; 128
	brne	1b		;/
  7e:	f8 94       	cli

	cpi	r30, '-'	;Minus sign if needed
  80:	b1 9b       	sbis	0x16, 1	; 22
	brne	5f		;
  82:	fe cf       	rjmp	.-4      	; 0x80 <rcvr+0x6>
	push	r30		;
  84:	b1 99       	sbic	0x16, 1	; 22
	inc	r31		;/
  86:	fe cf       	rjmp	.-4      	; 0x84 <rcvr+0xa>
5:	cp	r31, r18	;Filler
  88:	90 e1       	ldi	r25, 0x10	; 16
	brcc	6f		;
  8a:	9a 95       	dec	r25
	push	r19		;
  8c:	f1 f7       	brne	.-4      	; 0x8a <rcvr+0x10>
	inc	r31		;
  8e:	91 e2       	ldi	r25, 0x21	; 33
	rjmp	5b		;/
  90:	9a 95       	dec	r25

6:	pop	r24		;Flush stacked digits and exit
  92:	f1 f7       	brne	.-4      	; 0x90 <rcvr+0x16>
	rcall	xputc		;
  94:	86 95       	lsr	r24
	dec	r31		;
  96:	b1 99       	sbic	0x16, 1	; 22
	brne	6b		;/
  98:	80 68       	ori	r24, 0x80	; 128

	ret
  9a:	c8 f7       	brcc	.-14     	; 0x8e <rcvr+0x14>

#ifdef USE_XPRINTF
.global xprintf
.func xprintf
xprintf:
	push	YH
  9c:	0f be       	out	0x3f, r0	; 63
	push	YL
  9e:	08 95       	ret

000000a0 <main>:
	in	YL, _SFR_IO_ADDR(SPL)
  a0:	0f d0       	rcall	.+30     	; 0xc0 <initSerial>
#ifdef SPH
	in	YH, _SFR_IO_ADDR(SPH)
  a2:	d6 9a       	sbi	0x1a, 6	; 26
	clr	YH
#endif
#if FLASHEND > 0x1FFFF
	adiw	YL, 6		;Y = pointer to arguments
#else
	adiw	YL, 5		;Y = pointer to arguments
  a4:	80 e6       	ldi	r24, 0x60	; 96
#endif
	ld	ZL, Y+		;Z = pointer to format string
  a6:	90 e0       	ldi	r25, 0x00	; 0
	ld	ZH, Y+		;/
  a8:	15 d0       	rcall	.+42     	; 0xd4 <xprint>

0:	_LPMI	r24		;Get a format char
  aa:	8f e9       	ldi	r24, 0x9F	; 159
	cpi	r24, 0		;End of format string?
  ac:	96 e8       	ldi	r25, 0x86	; 134
	breq	90f		;/
  ae:	a1 e0       	ldi	r26, 0x01	; 1
	cpi	r24, '%'	;Is format?
  b0:	81 50       	subi	r24, 0x01	; 1
	breq	20f		;/
  b2:	90 40       	sbci	r25, 0x00	; 0
1:	rcall	xputc		;Put a normal character
  b4:	a0 40       	sbci	r26, 0x00	; 0
	rjmp	0b		;/
  b6:	e1 f7       	brne	.-8      	; 0xb0 <main+0x10>
90:	pop	YL
  b8:	00 c0       	rjmp	.+0      	; 0xba <main+0x1a>
	pop	YH
  ba:	00 00       	nop
	ret
  bc:	ce 9a       	sbi	0x19, 6	; 25

20:	ldi	r18, 0		;r18: digits
  be:	f2 cf       	rjmp	.-28     	; 0xa4 <main+0x4>

000000c0 <initSerial>:
	clt			;T: filler
  c0:	8d e2       	ldi	r24, 0x2D	; 45
	_LPMI	r21		;Get flags
  c2:	90 e0       	ldi	r25, 0x00	; 0
	cpi	r21, '%'	;Is a %?
  c4:	90 93 6f 00 	sts	0x006F, r25
	breq	1b		;/
	cpi	r21, '0'	;Zero filled?
  c8:	80 93 6e 00 	sts	0x006E, r24
	brne	23f		;
	set			;/
  cc:	b8 9a       	sbi	0x17, 0	; 23
22:	_LPMI	r21		;Get width
  ce:	b9 98       	cbi	0x17, 1	; 23
23:	cpi	r21, '9'+1	;
  d0:	c1 98       	cbi	0x18, 1	; 24
	brcc	24f		;
  d2:	08 95       	ret

000000d4 <xprint>:
	subi	r21, '0'	;
  d4:	ef 92       	push	r14
	brcs	90b		;
  d6:	ff 92       	push	r15
	lsl	r18		;
  d8:	cf 93       	push	r28
	mov	r0, r18		;
  da:	df 93       	push	r29
	lsl	r18		;
  dc:	e8 2e       	mov	r14, r24
	lsl	r18		;
  de:	e7 01       	movw	r28, r14
	add	r18, r0		;
  e0:	7e 01       	movw	r14, r28
	add	r18, r21	;
  e2:	f9 2e       	mov	r15, r25
	rjmp	22b		;/
  e4:	e7 01       	movw	r28, r14

24:	brtc	25f		;get value (low word)
  e6:	01 c0       	rjmp	.+2      	; 0xea <xprint+0x16>
	neg	r18		;
  e8:	b8 df       	rcall	.-144    	; 0x5a <xmit>
25:	ld	r24, Y+		;
  ea:	89 91       	ld	r24, Y+
	ld	r25, Y+		;/
  ec:	88 23       	and	r24, r24
	cpi	r21, 'c'	;Is type character?
  ee:	e1 f7       	brne	.-8      	; 0xe8 <xprint+0x14>
	breq	1b		;/
  f0:	df 91       	pop	r29
	cpi	r21, 's'	;Is type RAM string?
  f2:	cf 91       	pop	r28
	breq	50f		;/
  f4:	ff 90       	pop	r15
	cpi	r21, 'S'	;Is type ROM string?
  f6:	ef 90       	pop	r14
	breq	60f		;/
  f8:	08 95       	ret

000000fa <_exit>:
	_MOVW	r23,r22,r25,r24	;r25:r22 = value
  fa:	f8 94       	cli

000000fc <__stop_program>:
	clr	r24		;
  fc:	ff cf       	rjmp	.-2      	; 0xfc <__stop_program>
